# 刘浪|Part1|模块一
### 第一题
最终执行结果为：10

原因是因为  ：i 是var声明的，全局都有效，全局只有一个i，每一次循环,都会i发生改变，循环结束后 i=10。 最后console.log(i)就指向了全局的i就是10

### 第二题

最终执行结果为:报错 ReferenceError

原因是因为：存在全局变量tmp，但是块级作用域let又声明了一个局部变量tmp ，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。这在语法上，称为“暂时性死区”

### 第三题
```js
var arr =[12,34,32,89,4]
let min= arr.sort((a, b) => a - b)[0]
console.log(min) //4
```
### 第四题

var和let/const的区别
+ 块级作用域


+ 不存在变量提升


+ 暂时性死区


+ 不可重复声明


+ let、const声明的全局变量不会挂在顶层对象下面

const命令两个注意点:
+ const 声明之后必须马上赋值，否则会报错


+ const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。

### 第五题
最终执行结果为：20

原因是因为 this.a是在箭头函数里面，箭头函数没有this。this往上找。fn函数有this，obj调用了fn函数所以this指向obj 。

### 第六题
新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

作为一个可替换字符串或者整型使用的唯一值

作为一个对象中放置元信息（metadata）的场所

### 第七题

浅拷贝 ：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象