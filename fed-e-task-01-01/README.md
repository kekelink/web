# 刘浪|Part1|模块一
### 第一题
最终执行结果为：10

原因是因为  ：i 是var声明的，全局都有效，全局只有一个i，每一次循环,都会i发生改变，循环结束后 i=10。 最后console.log(i)就指向了全局的i就是10

### 第二题

最终执行结果为:报错 ReferenceError

原因是因为：存在全局变量tmp，但是块级作用域let又声明了一个局部变量tmp ，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。这在语法上，称为“暂时性死区”

### 第三题
```js
var arr =[12,34,32,89,4]
let min= arr.sort((a, b) => a - b)[0]
console.log(min) //4
```
### 第四题

var和let/const的区别
+ 块级作用域


+ 不存在变量提升


+ 暂时性死区


+ 不可重复声明


+ let、const声明的全局变量不会挂在顶层对象下面

const命令两个注意点:
+ const 声明之后必须马上赋值，否则会报错


+ const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。

### 第五题
最终执行结果为：20

原因是因为 this.a是在箭头函数里面，箭头函数没有this。this往上找。fn函数有this，obj调用了fn函数所以this指向obj 。

### 第六题
新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

作为一个可替换字符串或者整型使用的唯一值

作为一个对象中放置元信息（metadata）的场所

### 第七题

浅拷贝 ：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

### 第八题

异步简单说就是一个任务分成两段，先执行一段，转而执行其他任务，等做好了准备转而执行第二段。 

Event Loop:js是单线程的脚本语言，在同一时间，只能做一件事情。Event Loop防止主线程阻塞，执行异步操作、用户交互、脚本、UI渲染和网络处理等行为

宏任务： 就相当于去银行排队办业务，人多了就需要排队，当柜员处理完当前客户的问题以后，选择接待下一位，也就是下一个宏任务的开始。

微任务：  相当于排队排到你了，你存完钱，还想办理其他业务。柜员也会帮你办理，直到你没有其他想办理的业务了，这里就是所有微任务，然后就会下一位，进入下一个宏任务

### 第九题
```js

new Promise((resolve,reject)=>{
  resolve()
}).then(res=>{
  return 'hello'
}).then(res=>{
  return res+'lagou'
}).then(res=>{
  let c='i❤u'
  console.log(res+c);
  
})
```
### 第十题
TypeScript 是javaScript的超集，可以理解为增强版javaScript ,TypeScript主要提供了类型系统和对 ES6 的支持

### 第十一题
优点
+ TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可
+ 即使不显式的定义类型，也能够自动做出类型推论
+ 可以定义从简单到复杂的几乎一切类型
+ 即使 TypeScript 编译报错，也可以生成 JavaScript 文件
+ 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取

缺点

+ 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念
+ 可能和一些库结合的不是很完美 
+ 对于小型项目会有额外的开发成本